<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>3D Квиз</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, system-ui, sans-serif; }
    body {
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .app {
      width: 100%;
      max-width: 720px;
      background: rgba(255,255,255,0.96);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .logo-bar {
      height: 70px;
      background: #111827;
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 12px;
      color: #e5e7eb;
    }
    .logo-placeholder {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      color: #0b1120;
      font-size: 1.1rem;
      flex-shrink: 0;
    }
    .logo-text-main {
      font-size: 1rem;
      font-weight: 600;
    }
    .logo-text-sub {
      font-size: 0.78rem;
      color: #9ca3af;
    }

    .header {
      padding: 16px 20px 14px;
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .header-left h1 { font-size: 1.4rem; margin-bottom: 4px; }
    .header-left p { font-size: 0.9rem; opacity: 0.9; }
    .header-right { text-align: right; font-size: 0.8rem; }

    .progress-section {
      padding: 16px 20px 6px;
      background: #ffffff;
      border-bottom: 1px solid #e5e7eb;
    }
    .progress-top {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 0.85rem;
      color: #6b7280;
    }
    .score-bar {
      height: 12px;
      background: #f3f4f6;
      border-radius: 999px;
      overflow: hidden;
      position: relative;
    }
    .score-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #ff4757, #ffa502, #2ed573);
      border-radius: 999px;
      transition: width 0.6s ease;
      box-shadow: 0 0 18px rgba(34,197,94,0.5);
    }
    .score-text-main {
      margin-top: 8px;
      text-align: center;
      font-size: 1.05rem;
      font-weight: 600;
    }

    .question {
      padding: 22px 20px 24px;
      min-height: 220px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .question-num {
      font-size: 0.8rem;
      color: #6b7280;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .question-text {
      font-size: 1.2rem;
      font-weight: 600;
      line-height: 1.4;
    }

    .answers {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .answer-btn {
      padding: 12px 14px;
      border-radius: 12px;
      border: 2px solid #e5e7eb;
      background: #ffffff;
      cursor: pointer;
      font-size: 0.98rem;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: all 0.18s ease;
    }
    .answer-letter {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 2px solid #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 0.9rem;
      flex-shrink: 0;
    }
    .answer-btn:hover {
      border-color: #4facfe;
      box-shadow: 0 8px 20px rgba(79,172,254,0.3);
      transform: translateY(-1px);
    }
    .answer-btn.correct {
      border-color: #22c55e;
      background: #dcfce7;
      box-shadow: 0 8px 20px rgba(34,197,94,0.4);
    }
    .answer-btn.wrong {
      border-color: #ef4444;
      background: #fee2e2;
      box-shadow: 0 8px 20px rgba(239,68,68,0.4);
    }
    .answer-btn.disabled { pointer-events: none; opacity: 0.82; }

    .footer {
      padding: 14px 20px 16px;
      background: #f9fafb;
      border-top: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
    }
    .status { color: #6b7280; }
    .next-btn {
      padding: 10px 24px;
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      border: none;
      border-radius: 999px;
      font-size: 0.98rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.18s ease;
    }
    .next-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 28px rgba(79,172,254,0.5);
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.88);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
      backdrop-filter: blur(10px);
    }
    .overlay.active { display: flex; }
    .overlay-card {
      background: white;
      border-radius: 20px;
      padding: 32px 26px 28px;
      width: min(420px, 92vw);
      box-shadow: 0 28px 80px rgba(0,0,0,0.55);
      text-align: center;
    }
    .overlay-card h2 { font-size: 1.6rem; margin-bottom: 8px; }
    .overlay-card p { font-size: 0.95rem; color: #6b7280; }
    .result-stats {
      margin: 22px 0 8px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 0.98rem;
    }
    .stat-row { display: flex; justify-content: space-between; }
    .stat-row span:last-child { font-weight: 600; color: #4f46e5; }
    .final-bar {
      height: 14px;
      margin-top: 14px;
      border-radius: 999px;
      background: #f3f4f6;
      overflow: hidden;
    }
    .final-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #ff4757, #ffa502, #2ed573);
      transition: width 0.8s ease;
    }
    .overlay-btn {
      margin-top: 22px;
      width: 100%;
      padding: 11px 0;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 1rem;
    }

    .progress-top span b { font-weight: 600; }

    @media (max-width: 640px) {
      .logo-bar { padding: 0 14px; }
      .header { flex-direction: column; align-items: flex-start; gap: 6px; }
      .header-right { text-align: left; }
      .question-text { font-size: 1.05rem; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="logo-bar">
      <div class="logo-placeholder">3D</div>
      <div>
        <div class="logo-text-main">Твой логотип</div>
        <div class="logo-text-sub">Сюда потом поставишь свой PNG / название</div>
      </div>
    </div>

    <div class="header">
      <div class="header-left">
        <h1>3D‑квиз</h1>
        <p>20 случайных вопросов из сотни</p>
      </div>
      <div class="header-right">
        <div>Вопросов в раунде: <b id="totalPerRun">20</b></div>
        <div>Всего в базе: <b id="totalPool">100</b></div>
      </div>
    </div>

    <div class="progress-section">
      <div class="progress-top">
        <span>Прогресс: <b><span id="progNum">0</span>/<span id="progTotal">20</span></b></span>
        <span id="scoreMini">Счёт: 0</span>
      </div>
      <div class="score-bar">
        <div class="score-fill" id="scoreBar"></div>
      </div>
      <div class="score-text-main" id="scoreText">0/20</div>
    </div>

    <div class="question">
      <div class="question-num" id="qNum">Вопрос —</div>
      <div class="question-text" id="questionText">Нажмите «Пуск», чтобы начать раунд.</div>
      <div class="answers" id="answers"></div>
    </div>

    <div class="footer">
      <div class="status" id="status">Готово к старту.</div>
      <button class="next-btn" id="nextBtn">Пуск ➤</button>
    </div>
  </div>

  <div class="overlay active" id="startOverlay">
    <div class="overlay-card">
      <h2>3D‑квиз</h2>
      <p>Каждый раз новые 20 вопросов из большой базы. Попробуй набрать максимум и посмотреть, насколько ты 3D‑монстр.</p>
      <button class="overlay-btn" id="startBtn">Начать ➤</button>
    </div>
  </div>

  <div class="overlay" id="endOverlay">
    <div class="overlay-card">
      <h2 id="endTitle">Результаты</h2>
      <div class="result-stats">
        <div class="stat-row">
          <span>Правильных ответов:</span>
          <span id="endCorrect">0</span>
        </div>
        <div class="stat-row">
          <span>Всего в раунде:</span>
          <span id="endTotal">20</span>
        </div>
        <div class="stat-row">
          <span>Процент:</span>
          <span id="endPercent">0%</span>
        </div>
      </div>
      <div class="final-bar">
        <div class="final-fill" id="finalBar"></div>
      </div>
      <div id="endComment" style="margin-top:16px; font-size:0.98rem; color:#4b5563;"></div>
      <button class="overlay-btn" id="restartBtn">Сыграть ещё раз ⟳</button>
    </div>
  </div>

  <script>
    const QUESTIONS_PER_RUN = 20;

    const praiseMessages = [
      "Ты крут! Так держать.",
      "Шикарно, прям 3D‑самурай.",
      "Красота, вот это уровень.",
      "Имба, а не ответ.",
      "Вау, да ты в теме!",
      "Так и становятся синьорами."
    ];

    const failMessages = [
      "Печаль, но всё исправимо.",
      "Грустненько, но ты справишься.",
      "Чуть‑чуть мимо, зато опыт.",
      "Не страшно, главное — дальше жать вперёд.",
      "Не вышло, но потенциал чувствуется.",
      "Ошибки — это тоже прогресс."
    ];

    const allQuestions = [
      // 1–10 базовые полигоны/гео
      {
        text: "Что такое полигон в 3D‑модели?",
        options: [
          "Любая плоская картинка в сцене",
          "Минимальная плоская часть меша, ограниченная вершинами и рёбрами",
          "Любой трёхмерный объект в сцене",
          "Специальный тип текстуры"
        ],
        correctIndex: 1
      },
      {
        text: "Из каких основных элементов состоит полигональная сетка (mesh)?",
        options: [
          "Пиксели, слои и фильтры",
          "Вершины, рёбра и грани",
          "Кадры, ключи и кривые",
          "Шрифты, параграфы и стили"
        ],
        correctIndex: 1
      },
      {
        text: "Что лучше всего описывает понятие «mesh»?",
        options: [
          "Один полигон без связей",
          "Коллекция связанных полигонов, образующих объект",
          "Только материалы без геометрии",
          "Только анимация персонажа"
        ],
        correctIndex: 1
      },
      {
        text: "Чем low poly‑модель отличается от high poly?",
        options: [
          "Low poly всегда реалистичнее",
          "Low poly содержит меньше полигонов при сохранении общей формы",
          "High poly нельзя использовать в рендере",
          "High poly не подходит для скульпта"
        ],
        correctIndex: 1
      },
      {
        text: "В каком случае чаще всего используют low poly‑модели?",
        options: [
          "Для real‑time игр и мобильных приложений",
          "Только для печати на бумаге",
          "Исключительно для 2D‑анимации",
          "Только для статичных постеров 8K"
        ],
        correctIndex: 0
      },
      {
        text: "Что показывает режим отображения wireframe?",
        options: [
          "Только материалы и освещение",
          "Скелет рига без геометрии",
          "Только UV‑развёртку",
          "Структуру рёбер и полигонов без заливки"
        ],
        correctIndex: 3
      },
      {
        text: "Что такое N‑gon в 3D‑моделировании?",
        options: [
          "Полигон строго из четырёх вершин",
          "Полигон с количеством вершин больше четырёх",
          "Всегда треугольник",
          "Специальный тип нормалей"
        ],
        correctIndex: 1
      },
      {
        text: "Почему N‑gons не рекомендуют оставлять в зонах деформации?",
        options: [
          "Они делают рендер невозможным",
          "Они часто ломаются при subdivision и анимации",
          "Они запрещены в игровых движках",
          "Они автоматически превращаются в текстуры"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое нормаль поверхности?",
        options: [
          "Направление камеры в сцене",
          "Вектор, перпендикулярный поверхности полигона",
          "Направление скелетной кости",
          "Тип карты текстур"
        ],
        correctIndex: 1
      },
      {
        text: "В чём разница между глобальными (world) и локальными (local) координатами объекта?",
        options: [
          "Глобальные всегда равны нулю",
          "Локальные считаются от собственного центра объекта, глобальные — от начала сцены",
          "Глобальные есть только в играх",
          "Локальные используются только для камер"
        ],
        correctIndex: 1
      },

      // 11–20 моделирование
      {
        text: "Чем полигональное моделирование отличается от NURBS‑моделирования?",
        options: [
          "Полигональное основано на сетке, NURBS — на кривых",
          "NURBS всегда даёт меньше деталей",
          "Полигональное нельзя анимировать",
          "NURBS используют только в играх"
        ],
        correctIndex: 0
      },
      {
        text: "Что такое box‑моделинг?",
        options: [
          "Моделирование только примитивом сфера",
          "Пошаговое усложнение формы, начиная с простого куба/бокса",
          "Только скульпт без сетки",
          "Автоматическая генерация персонажа"
        ],
        correctIndex: 1
      },
      {
        text: "Для чего применяют subdivision (сабдив) к модели?",
        options: [
          "Чтобы уменьшить количество полигонов",
          "Чтобы сделать модель более гладкой и детализированной",
          "Чтобы удалить все вершины",
          "Чтобы обнулить трансформации"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем при моделировании персонажа используют модификатор Mirror?",
        options: [
          "Чтобы добавить отражения в материале",
          "Чтобы дублировать половину модели и сохранить симметрию",
          "Чтобы ускорить рендер",
          "Чтобы скрыть часть модели"
        ],
        correctIndex: 1
      },
      {
        text: "Какую задачу решает bevel на рёбрах?",
        options: [
          "Удаляет лишние полигоны",
          "Смягчает переходы и создаёт фаски на краях",
          "Меняет масштаб сцены",
          "Делает модель прозрачной"
        ],
        correctIndex: 1
      },
      {
        text: "В каких случаях удобнее начинать с high‑poly скульпта, а не с low‑poly сетки?",
        options: [
          "Когда нужна органика и сложные, плавные формы",
          "Когда модель — обычный куб",
          "Когда нет текстур",
          "Когда модель не будет анимироваться"
        ],
        correctIndex: 0
      },
      {
        text: "Для чего используют Boolean‑операции (union, difference, intersect)?",
        options: [
          "Для настройки освещения",
          "Для слияния и вырезания форм на уровне геометрии",
          "Только для анимации камеры",
          "Для изменения цвета текстур"
        ],
        correctIndex: 1
      },
      {
        text: "Что обычно называют блокингом (blockout) модели?",
        options: [
          "Финальный high‑poly скульпт",
          "Черновую форму из простых примитивов с правильными пропорциями",
          "Чистовую UV‑развёртку",
          "Только настройку материалов"
        ],
        correctIndex: 1
      },
      {
        text: "Почему при моделировании персонажа уделяют внимание сетке вокруг суставов?",
        options: [
          "Чтобы там было меньше вершин",
          "Эти зоны не анимируются",
          "Сетка должна хорошо деформироваться при сгибах",
          "Чтобы туда проще было назначать материалы"
        ],
        correctIndex: 2
      },
      {
        text: "Чем hard‑surface моделирование отличается от органического?",
        options: [
          "Hard‑surface — жёсткие техно‑формы, органика — живые плавные формы",
          "Hard‑surface нельзя анимировать",
          "Органика не бывает high‑poly",
          "Hard‑surface всегда low poly"
        ],
        correctIndex: 0
      },

      // 21–30 топология
      {
        text: "Что такое edge loop?",
        options: [
          "Последовательность рёбер, образующая логичный контур по поверхности",
          "Отдельное ребро без вершин",
          "Специальная текстура",
          "Скелетный сустав"
        ],
        correctIndex: 0
      },
      {
        text: "Почему плохая топология может вызвать артефакты при анимации?",
        options: [
          "Материалы перестают работать",
          "Свет не рендерится",
          "Сетка деформируется неравномерно и ломается в зонах сгиба",
          "Модель становится невидимой"
        ],
        correctIndex: 2
      },
      {
        text: "Что такое «полюс» (pole) в сетке?",
        options: [
          "Вершина, в которой сходится много рёбер",
          "Точка для крепления камеры",
          "Центр мировой координат",
          "Особый вид текстуры"
        ],
        correctIndex: 0
      },
      {
        text: "Почему треугольники и N‑gons стараются уводить из зон активной деформации?",
        options: [
          "Они всегда делают модель прозрачной",
          "Они не рендерятся в играх",
          "Они непредсказуемо subdiv‑ятся и ломают деформацию",
          "Так быстрее экспортируется FBX"
        ],
        correctIndex: 2
      },
      {
        text: "Для чего добавляют supporting edges на жёстких краях?",
        options: [
          "Чтобы уменьшить количество текстур",
          "Чтобы сохранить чёткий силуэт после subdivision",
          "Чтобы удалить нормали",
          "Чтобы изменить UV‑развёртку"
        ],
        correctIndex: 1
      },
      {
        text: "Что обычно подразумевают под «чистой топологией» лица?",
        options: [
          "Минимальное количество вершин",
          "Случайное расположение полигонов",
          "Логичные петли вокруг глаз, рта и носа для мимики",
          "Отсутствие UV‑развёртки"
        ],
        correctIndex: 2
      },
      {
        text: "Почему важно избегать слишком вытянутых узких полигонов?",
        options: [
          "Они не поддерживаются видеокартами",
          "Они плохо ведут себя при деформации и освещении",
          "Они автоматически превращаются в N‑gons",
          "Их нельзя текстурировать"
        ],
        correctIndex: 1
      },
      {
        text: "Как по сетке понять, что модель делали под subdivision, а не под game‑lowpoly?",
        options: [
          "Очень редкая сетка без контуров",
          "Равномерные квады и поддерживающие рёбра вдоль краёв",
          "Только треугольники",
          "Только N‑gons"
        ],
        correctIndex: 1
      },
      {
        text: "Почему треугольники допустимы на статичных частях модели?",
        options: [
          "Они автоматически анимируются",
          "Они не влияют на деформацию, если зона не сгибается",
          "Они ускоряют свет",
          "Они заменяют текстуры"
        ],
        correctIndex: 1
      },
      {
        text: "Что говорит о том, что сетка персонажа оптимизирована под мобильную игру?",
        options: [
          "Много мелких деталей и очень плотная сетка",
          "Минимум полигонов, акцент на силуэт и нормали",
          "Только N‑gons",
          "Отсутствие UV"
        ],
        correctIndex: 1
      },

      // 31–40 текстуры / PBR
      {
        text: "Что такое текстура в 3D‑графике?",
        options: [
          "Всегда только цвет объекта",
          "2D‑изображение, проецируемое на поверхность модели",
          "Тип источника света",
          "Скелет для анимации"
        ],
        correctIndex: 1
      },
      {
        text: "Чем диффузная (albedo) карта отличается от normal map?",
        options: [
          "Albedo задаёт цвет, normal — микрорельеф для освещения",
          "Normal отвечает за прозрачность",
          "Albedo управляет металличностью",
          "Они взаимозаменяемы"
        ],
        correctIndex: 0
      },
      {
        text: "Какую роль играет roughness‑карта в PBR‑материале?",
        options: [
          "Управляет высотой геометрии",
          "Определяет шероховатость поверхности и размытие бликов",
          "Отвечает за цвет тени",
          "Контролирует скорость анимации"
        ],
        correctIndex: 1
      },
      {
        text: "Чем bump map отличается от normal map?",
        options: [
          "Bump хранит высоту в одном канале, normal — направление нормали в трёх",
          "Normal используется только в 2D",
          "Bump не влияет на освещение",
          "Разницы нет"
        ],
        correctIndex: 0
      },
      {
        text: "Что кодирует metallic‑карта в PBR?",
        options: [
          "Температуру света",
          "Области поверхности, которые ведут себя как металл",
          "Прозрачные участки",
          "Размер модели"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем используют ambient occlusion‑карту?",
        options: [
          "Для управления движением камеры",
          "Для добавления мягких теней в углублениях формы",
          "Для настройки DOF",
          "Для сжатия текстур"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое procedural‑текстуры?",
        options: [
          "Всегда рисованные вручную",
          "Генерируемые алгоритмами, а не хранящиеся как обычные изображения",
          "Только HDR",
          "Текстуры, которые нельзя редактировать"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое seamless‑текстура?",
        options: [
          "Текстура с прозрачным фоном",
          "Текстура, которая повторяется без видимых швов",
          "Всегда чёрно‑белая карта",
          "Текстура только для персонажей"
        ],
        correctIndex: 1
      },
      {
        text: "Почему важно соблюдать единый стиль текстур в одной сцене?",
        options: [
          "Иначе рендер не запустится",
          "Чтобы сцена не выглядела собранной из чужих ассетов",
          "Чтобы уменьшить размер файла",
          "Чтобы ускорить импорт"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое tiling текстур?",
        options: [
          "Случайное вращение текстур",
          "Повторение одной и той же текстуры по поверхности",
          "Удаление текстур",
          "Сжатие текстур"
        ],
        correctIndex: 1
      },

      // 41–50 UV
      {
        text: "Что такое UV‑развёртка?",
        options: [
          "Анимация камеры",
          "Схема соответствия точек модели координатам 2D‑текстуры",
          "Настройка рендера",
          "Набор ключевых кадров"
        ],
        correctIndex: 1
      },
      {
        text: "Почему без корректной UV‑развёртки сложно нанести детализированную текстуру?",
        options: [
          "Модель не рендерится",
          "Текстура будет растягиваться и смещаться случайно",
          "Текстуры нельзя импортировать",
          "Нормали перестают работать"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое UV‑seam?",
        options: [
          "Ребро, по которому разорван UV‑остров",
          "Тип источника света",
          "Центр мира",
          "Особый режим рендера"
        ],
        correctIndex: 0
      },
      {
        text: "Зачем для проверки UV используют checker‑текстуру (клетку)?",
        options: [
          "Чтобы усилить блики",
          "Чтобы увидеть растяжения и неправильный масштаб",
          "Чтобы ускорить рендер",
          "Чтобы добавить бамп"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое оверлап (overlapping UVs)?",
        options: [
          "Всегда фатальная ошибка",
          "Наложение нескольких UV‑островов друг на друга",
          "Смещение источников света",
          "Особый тип нормалей"
        ],
        correctIndex: 1
      },
      {
        text: "Когда допустимо использовать overlapping UVs?",
        options: [
          "Никогда",
          "Когда можно зеркалить детали и экономить текстурное место",
          "Только в оффлайн‑рендере",
          "Только для камер"
        ],
        correctIndex: 1
      },
      {
        text: "Почему при запекании нормалей важно избегать случайного UV‑оверлапа?",
        options: [
          "Иначе модель станет прозрачной",
          "Информация с разных участков high‑poly смешается и даст артефакты",
          "Нормали выключатся",
          "Размер текстуры уменьшится"
        ],
        correctIndex: 1
      },
      {
        text: "Что показывает равномерный размер клеток checker‑текстуры на модели?",
        options: [
          "Что модель слишком low poly",
          "Что масштаб UV примерно одинаков и без сильных растяжений",
          "Что текстур нет",
          "Что освещение некорректно"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем иногда разделяют UV‑острова по швам модели?",
        options: [
          "Чтобы усложнить жизнь текстурщику",
          "Чтобы уменьшить растяжения и увести швы в менее заметные места",
          "Чтобы отключить тени",
          "Чтобы удалить нормали"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое UDIM‑подход?",
        options: [
          "Использование только одной текстуры 1×1",
          "Разбиение модели на несколько тайлов UV‑пространства для высоких разрешений",
          "Отказ от UV‑развёртки",
          "Только процедурные материалы"
        ],
        correctIndex: 1
      },

      // 51–60 свет / рендер
      {
        text: "Чем point light отличается от directional light?",
        options: [
          "Point светит из точки во все стороны, directional — как параллельный поток из бесконечности",
          "Directional нельзя использовать в играх",
          "Point не даёт теней",
          "Разницы нет"
        ],
        correctIndex: 0
      },
      {
        text: "Что такое HDRI‑карта в освещении?",
        options: [
          "Чёрно‑белая маска",
          "Панорамное изображение с расширенным диапазоном яркости, используемое как источник света и окружение",
          "Низкокачественная текстура",
          "Тип геометрии"
        ],
        correctIndex: 1
      },
      {
        text: "Что даёт глобальное освещение (Global Illumination) сцене?",
        options: [
          "Только ускорение рендера",
          "Учёт переотражений света от поверхностей для реалистичных теней и цвета",
          "Отсутствие теней",
          "Отключение всех источников света"
        ],
        correctIndex: 1
      },
      {
        text: "Почему слишком много ярких источников света может сделать сцену «плоской»?",
        options: [
          "Рендер становится чёрно‑белым",
          "Тени пропадают и теряется контраст объёмов",
          "Материалы исчезают",
          "Камера не работает"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое soft shadow?",
        options: [
          "Тень без света",
          "Жёсткая чёрная тень",
          "Мягкая тень с размытым краем от большого/дальнего источника",
          "Отсутствие тени"
        ],
        correctIndex: 2
      },
      {
        text: "Что такое depth of field (глубина резкости) в рендере?",
        options: [
          "Измерение глубины модели",
          "Эффект резкости в одной зоне и размытия переднего/заднего плана",
          "Тип рендера без света",
          "Только эффект в видеоредакторе"
        ],
        correctIndex: 1
      },
      {
        text: "Чем real‑time рендер в игровом движке обычно отличается от offline‑рендера?",
        options: [
          "Он всегда точнее по физике",
          "Он быстрее, но ограничен по сложности света и материалов",
          "Он не использует текстуры",
          "Он не подходит для игр"
        ],
        correctIndex: 1
      },
      {
        text: "Почему на path‑tracing рендерах появляется шум (noise)?",
        options: [
          "Неверный формат текстуры",
          "Недостаточно сэмплов для оценки света и переотражений",
          "Слишком много полигонов",
          "Слишком длинное имя файла"
        ],
        correctIndex: 1
      },
      {
        text: "Что делает эффект motion blur в анимации?",
        options: [
          "Удаляет все ключи",
          "Имитация смаза движения при перемещении объектов или камеры",
          "Меняет цвет материалов",
          "Выключает освещение"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое ambient light в сцене?",
        options: [
          "Направленный жёсткий источник",
          "Фоновый рассеянный свет, заполняющий тени",
          "Всегда красный свет",
          "Только для мобильных игр"
        ],
        correctIndex: 1
      },

      // 61–70 игры / realtime
      {
        text: "Почему для игровых моделей важно ограничивать количество полигонов?",
        options: [
          "Чтобы файл открывался только в одной программе",
          "Чтобы укладываться в бюджет по производительности и памяти",
          "Чтобы модель нельзя было анимировать",
          "Чтобы отключить текстуры"
        ],
        correctIndex: 1
      },
      {
        text: "Чем модель для in‑game отличается от модели для кат‑сцены/прома?",
        options: [
          "In‑game обычно более оптимизирована по полигонам и текстурам",
          "Кат‑сцену нельзя анимировать",
          "Промо‑модель всегда без текстур",
          "Разницы нет"
        ],
        correctIndex: 0
      },
      {
        text: "Что такое LOD‑модели?",
        options: [
          "Только модели для VR",
          "Несколько уровней детализации одного объекта для разных дистанций",
          "Модели без текстур",
          "Модели только для рендера"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое atlas‑текстура?",
        options: [
          "Текстура только для карт",
          "Одна текстура, на которой размещено несколько объектов/деталей",
          "Текстура с картой нормалей и высот",
          "Всегда 8К текстура"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем создают отдельную collision‑модель?",
        options: [
          "Чтобы улучшить цвет объекта",
          "Чтобы упростить просчёт столкновений и физики",
          "Чтобы сделать UV‑развёртку",
          "Чтобы ускорить рендер оффлайн"
        ],
        correctIndex: 1
      },
      {
        text: "Чем baked lighting отличается от динамического освещения?",
        options: [
          "Baked нельзя сохранять",
          "Baked заранее запекается в текстуры/карты, динамическое считается в реальном времени",
          "Динамическое всегда чёрно‑белое",
          "Разницы нет"
        ],
        correctIndex: 1
      },
      {
        text: "Почему важно следить за направлением нормалей на игровых моделях?",
        options: [
          "Иначе UV не создаются",
          "Неправильные нормали могут вызывать чёрные дырки и странные тени",
          "Текстуры не импортируются",
          "Камера не двигается"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое skeletal animation?",
        options: [
          "Анимация только камер",
          "Анимация на основе скелета с костями и скинингом меша",
          "Анимация текстур",
          "Только 2D‑анимация"
        ],
        correctIndex: 1
      },
      {
        text: "Почему в real‑time сценах часто используют low poly + нормали вместо чистого high poly?",
        options: [
          "High poly нельзя экспортировать",
          "Low poly с нормалями даёт похожий визуал при меньшей нагрузке",
          "Low poly лучше для оффлайн‑рендера",
          "High poly не поддерживают видеокарты"
        ],
        correctIndex: 1
      },
      {
        text: "По какому признаку можно заметить, что модели в игре не используют normal map?",
        options: [
          "Сцена чёрно‑белая",
          "Поверхности выглядят слишком плоско, без микрорельефа и градаций света",
          "Все материалы прозрачные",
          "UV‑развёртки отсутствуют"
        ],
        correctIndex: 1
      },

      // 71–80 high poly / bake
      {
        text: "Зачем делают high‑poly скульпт, если в игре всё равно low‑poly?",
        options: [
          "Чтобы увеличить вес файла",
          "Чтобы запечь на low‑poly карты с деталями (normal, AO и т.п.)",
          "Чтобы модель нельзя было экспортировать",
          "Чтобы не делать UV"
        ],
        correctIndex: 1
      },
      {
        text: "Что обычно запекают с high‑poly на low‑poly?",
        options: [
          "Только анимацию",
          "Информацию о деталях поверхности: нормали, AO, иногда высоту",
          "Камеры и свет",
          "Размер сцены"
        ],
        correctIndex: 1
      },
      {
        text: "Почему плохая топология на high‑poly усложняет ретопологию?",
        options: [
          "Ретопология становится невозможной технически",
          "Сложнее понять логику форм и проложить чистые лупы",
          "UV нельзя сделать",
          "Текстуры не работают"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем добавляют вторичные и третичные детали (поры, мелкие царапины) на high‑poly?",
        options: [
          "Чтобы увеличить количество полигонов ради спорта",
          "Чтобы при запекании получить реалистичный микрорельеф",
          "Чтобы облегчить модель",
          "Чтобы убрать нормали"
        ],
        correctIndex: 1
      },
      {
        text: "Почему чрезмерный шум деталей на high‑poly плохо переносится в низком разрешении текстур?",
        options: [
          "Он делает UV невозможной",
          "Детали превращаются в кашу и выглядят грязно",
          "Тени пропадают",
          "Свет не рассчитывается"
        ],
        correctIndex: 1
      },
      {
        text: "Чем отличается high‑poly персонаж для статичного рендера от игрового варианта?",
        options: [
          "Игровой обычно сильно оптимизирован по полигонам и текстурам",
          "Игровой всегда без текстур",
          "Статичный нельзя рендерить",
          "Разницы нет"
        ],
        correctIndex: 0
      },
      {
        text: "Как по нормал‑карте можно заметить артефакты запекания?",
        options: [
          "Если она чёрно‑белая",
          "Рваные швы, резкие полосы и ломанные переходы",
          "Если она слишком цветная",
          "Если она больше 1К"
        ],
        correctIndex: 1
      },
      {
        text: "Когда displacement‑карта оправдана даже в real‑time?",
        options: [
          "Никогда",
          "В близких кинематографичных кадрах, где нужна геометрическая детализация",
          "Только для UI",
          "Только для скелета"
        ],
        correctIndex: 1
      },
      {
        text: "Почему для bake важно совпадение позиций и масштаба high‑poly и low‑poly?",
        options: [
          "Чтобы рендер был цветным",
          "Чтобы лучи запекания правильно попадали с high на low",
          "Чтобы UV не исчезла",
          "Чтобы уменьшить размер файла"
        ],
        correctIndex: 1
      },
      {
        text: "Какой плюс даёт использование cage‑меша при запекании?",
        options: [
          "Ускоряет анимацию",
          "Позволяет контролировать направление лучей и уменьшить артефакты",
          "Удаляет UV",
          "Меняет цвет нормалей"
        ],
        correctIndex: 1
      },

      // 81–90 пайплайн / профессии
      {
        text: "Какой порядок этапов ближе к реальному пайплайну персонажа для игры?",
        options: [
          "Текстуры → концепт → риг",
          "Концепт → моделинг → текстуринг → риг → анимация → интеграция",
          "Риг → анимация → концепт → моделинг",
          "Интеграция → моделинг → концепт"
        ],
        correctIndex: 1
      },
      {
        text: "Кто такой 3D generalist?",
        options: [
          "Художник только по текстурам",
          "Специалист, который закрывает несколько этапов пайплайна",
          "Только риггер",
          "Только композитор"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем нужен turnaround‑референс персонажа?",
        options: [
          "Чтобы проверить FPS",
          "Чтобы моделлер видел персонажа спереди, сзади и сбоку с согласованными пропорциями",
          "Чтобы настроить свет",
          "Чтобы сделать UV"
        ],
        correctIndex: 1
      },
      {
        text: "Почему важно заранее договориться о стилистике (realistic / stylized)?",
        options: [
          "Иначе нельзя экспортировать модель",
          "Чтобы моделинг, текстуры и свет не конфликтовали по визуалу",
          "Чтобы выбрать размер текстур",
          "Чтобы задать количество костей"
        ],
        correctIndex: 1
      },
      {
        text: "Что подразумевают под non‑destructive workflow в моделинге?",
        options: [
          "Удаление истории действий",
          "Использование модификаторов и процедурных шагов, которые можно править позже",
          "Работу без сохранений",
          "Отказ от UV"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем в продакшене нужна аккуратная система имён файлов, коллекций и материалов?",
        options: [
          "Чтобы увеличить вес проекта",
          "Чтобы команда быстро ориентировалась в сцене и избежала путаницы",
          "Чтобы рендер был быстрее",
          "Чтобы включить PBR"
        ],
        correctIndex: 1
      },
      {
        text: "Как 3D‑графика помогает в архитектурной визуализации?",
        options: [
          "Считает смету стройки",
          "Позволяет показать, как будет выглядеть пространство ещё до строительства",
          "Пишет юридические документы",
          "Меняет температуру в помещении"
        ],
        correctIndex: 1
      },
      {
        text: "Чем пайплайн персонажа для анимационного фильма отличается от игрового?",
        options: [
          "В фильме нет рига",
          "В кино можно позволить сложнее риг, больше полигонов и тяжёлые симуляции",
          "В играх не нужно текстурирование",
          "Разницы нет"
        ],
        correctIndex: 1
      },
      {
        text: "Кто в команде обычно отвечает за постановку света и финальный рендер?",
        options: [
          "Rigging artist",
          "Lighting / LookDev artist",
          "Concept artist",
          "UI designer"
        ],
        correctIndex: 1
      },
      {
        text: "Кто чаще всего подготавливает ассеты под оптимизацию для движка (LOD, коллизии, атласы)?",
        options: [
          "Sound designer",
          "Technical / game artist",
          "Storyboard artist",
          "Motion designer 2D"
        ],
        correctIndex: 1
      },

      // 91–100 общие / микс
      {
        text: "Что даёт хорошая силуетная читаемость модели персонажа?",
        options: [
          "Быстрый рендер",
          "Персонажа легко узнают даже без деталей и текстур",
          "Меньше полигонов",
          "Проще UV"
        ],
        correctIndex: 1
      },
      {
        text: "Почему важно регулярно проверять модель в разных ракурсах и фокусных расстояниях камеры?",
        options: [
          "Чтобы менять цвет",
          "Чтобы избежать странных пропорций и искажений в финальных планах",
          "Чтобы уменьшить размер файла",
          "Чтобы отключить тени"
        ],
        correctIndex: 1
      },
      {
        text: "Чем 3D‑анимация отличается от простой покадровой смены статичных рендеров?",
        options: [
          "Наличием рига и интерполяции между позами во времени",
          "Только размером файла",
          "Использованием 2D‑спрайтов",
          "Отказом от камер"
        ],
        correctIndex: 0
      },
      {
        text: "Почему сцена с идеальными зеркальными материалами может выглядеть «ненастояще»?",
        options: [
          "Так не бывает в реальности, почти все поверхности имеют roughness",
          "Рендер не поддерживает зеркала",
          "Нельзя добавить свет",
          "Слишком мало полигонов"
        ],
        correctIndex: 0
      },
      {
        text: "Какую ключевую роль играет reference при работе 3D‑художника?",
        options: [
          "Увеличивает время работы",
          "Помогает принимать осознанные решения по форме, материалам и свету",
          "Запрещает фантазию",
          "Нужен только новичкам"
        ],
        correctIndex: 1
      },
      {
        text: "Почему важно следить за реальным масштабом объектов в сцене (метры, сантиметры)?",
        options: [
          "Иначе файл не откроется",
          "От масштаба зависят свет, физика, симуляции и удобство работы",
          "Только чтобы выбрать размер текстуры",
          "В масштабе нет смысла"
        ],
        correctIndex: 1
      },
      {
        text: "Какая главная цель ретопологии high‑poly модели?",
        options: [
          "Сделать модель тяжелее",
          "Создать чистую, оптимизированную сетку для анимации и игр",
          "Удалить детали",
          "Изменить цвет материалов"
        ],
        correctIndex: 1
      },
      {
        text: "Что даёт использование reference‑кадров из фильмов и игр при изучении света и композиции?",
        options: [
          "Только копирование стиля",
          "Понимание, как профи решают сцены по свету и цвету",
          "Увеличение шума на рендерах",
          "Снижение FPS"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем 3D‑графику используют в кино, даже когда можно снять всё вживую?",
        options: [
          "Чтобы усложнить монтаж",
          "Чтобы создавать миры, объекты и эффекты, которые невозможно или слишком дорого снимать реально",
          "Только ради титров",
          "Чтобы уменьшить качество картинки"
        ],
        correctIndex: 1
      },
      {
        text: "Как 3D‑художнику помогает знание основ фотографии (композиция, свет, фокусное расстояние)?",
        options: [
          "Совсем не связано",
          "Прямо влияет на качество рендера и восприятие кадра",
          "Только мешает",
          "Нужно лишь для печати"
        ],
        correctIndex: 1
      }
    ];

    let selectedQuestions = [];
    let currentIndex = 0;
    let score = 0;
    let answered = false;
    let quizStarted = false;

    const els = {
      progNum: document.getElementById('progNum'),
      progTotal: document.getElementById('progTotal'),
      scoreMini: document.getElementById('scoreMini'),
      scoreBar: document.getElementById('scoreBar'),
      scoreText: document.getElementById('scoreText'),
      qNum: document.getElementById('qNum'),
      questionText: document.getElementById('questionText'),
      answers: document.getElementById('answers'),
      status: document.getElementById('status'),
      nextBtn: document.getElementById('nextBtn'),
      startOverlay: document.getElementById('startOverlay'),
      endOverlay: document.getElementById('endOverlay'),
      startBtn: document.getElementById('startBtn'),
      restartBtn: document.getElementById('restartBtn'),
      endCorrect: document.getElementById('endCorrect'),
      endTotal: document.getElementById('endTotal'),
      endPercent: document.getElementById('endPercent'),
      finalBar: document.getElementById('finalBar'),
      endComment: document.getElementById('endComment'),
      totalPerRun: document.getElementById('totalPerRun'),
      totalPool: document.getElementById('totalPool')
    };

    els.totalPerRun.textContent = QUESTIONS_PER_RUN;
    els.progTotal.textContent = QUESTIONS_PER_RUN;
    els.endTotal.textContent = QUESTIONS_PER_RUN;
    els.totalPool.textContent = allQuestions.length;

    function pickQuestions() {
      const indices = allQuestions.map((_, i) => i);
      indices.sort(() => Math.random() - 0.5);
      const slice = indices.slice(0, QUESTIONS_PER_RUN);
      selectedQuestions = slice.map(i => ({ ...allQuestions[i] }));
    }

    function randFrom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function startQuiz() {
      pickQuestions();
      currentIndex = 0;
      score = 0;
      quizStarted = true;
      els.startOverlay.classList.remove('active');
      els.endOverlay.classList.remove('active');
      els.status.textContent = "Выберите ответ.";
      updateProgress();
      renderQuestion();
    }

    function updateProgress() {
      els.progNum.textContent = currentIndex;
      els.scoreMini.textContent = `Счёт: ${score}`;
      els.scoreText.textContent = `${score}/${QUESTIONS_PER_RUN}`;
      const progress = (currentIndex / QUESTIONS_PER_RUN) * 100;
      els.scoreBar.style.width = progress + "%";
    }

    function renderQuestion() {
      const q = selectedQuestions[currentIndex];
      answered = false;
      els.qNum.textContent = `Вопрос ${currentIndex + 1} из ${QUESTIONS_PER_RUN}`;
      els.questionText.textContent = q.text;
      els.answers.innerHTML = "";
      els.status.textContent = "Выберите ответ.";
      const letters = "ABCDE".split("");

      q.options.forEach((opt, i) => {
        const btn = document.createElement("button");
        btn.className = "answer-btn";
        btn.innerHTML = `
          <div class="answer-letter">${letters[i] || ""}</div>
          <span>${opt}</span>
        `;
        btn.onclick = () => handleAnswer(i, btn);
        els.answers.appendChild(btn);
      });

      els.nextBtn.textContent = currentIndex === QUESTIONS_PER_RUN - 1 ? "Результат" : "Далее ➤";
      updateProgress();
    }

    function handleAnswer(selectedIndex, btnEl) {
      if (!quizStarted || answered) return;
      answered = true;

      const q = selectedQuestions[currentIndex];
      const buttons = els.answers.querySelectorAll(".answer-btn");

      buttons.forEach((b, i) => {
        b.classList.add("disabled");
        if (i === q.correctIndex) b.classList.add("correct");
      });

      if (selectedIndex === q.correctIndex) {
        score++;
        btnEl.classList.add("correct");
        els.status.textContent = randFrom(praiseMessages);
      } else {
        btnEl.classList.add("wrong");
        els.status.textContent = randFrom(failMessages);
      }

      els.scoreMini.textContent = `Счёт: ${score}`;
      els.scoreText.textContent = `${score}/${QUESTIONS_PER_RUN}`;
    }

    function showResults() {
      const percent = Math.round((score / QUESTIONS_PER_RUN) * 100);
      els.endCorrect.textContent = score;
      els.endPercent.textContent = percent + "%";
      els.finalBar.style.width = percent + "%";

      let comment;
      if (percent >= 85) comment = "🔥 Жёстко! Ты реально шаришь в 3D.";
      else if (percent >= 60) comment = "👍 Уверенный уровень, можно уже мидлиться.";
      else if (percent >= 30) comment = "📚 База есть, докрути теорию и будет топ.";
      else comment = "🚀 Старт сделан. Если продолжишь, будешь разваливать 3D‑мир.";

      els.endComment.textContent = comment;
      els.endOverlay.classList.add("active");
    }

    els.nextBtn.onclick = () => {
      if (!quizStarted) {
        startQuiz();
        return;
      }
      if (!answered) return;
      if (currentIndex < QUESTIONS_PER_RUN - 1) {
        currentIndex++;
        renderQuestion();
      } else {
        showResults();
      }
    };

    els.startBtn.onclick = startQuiz;
    els.restartBtn.onclick = startQuiz;
  </script>
</body>
</html>
