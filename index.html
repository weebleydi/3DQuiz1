<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>3D Квиз</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    *{margin:0;padding:0;box-sizing:border-box;font-family:-apple-system,system-ui,sans-serif;}

    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      color:#111827;

      background:
        radial-gradient(circle at 0 0,#e0f2fe 0,transparent 55%),
        radial-gradient(circle at 100% 0,#fee2e2 0,transparent 55%),
        radial-gradient(circle at 50% 100%,#fef9c3 0,#eef2ff 60%);
      background-size:160% 160%;
      animation:bgFlow 18s ease-in-out infinite alternate;
    }

    @keyframes bgFlow{
      0%{
        background-position:0% 0%,100% 0%,50% 100%;
        filter:hue-rotate(0deg);
      }
      50%{
        background-position:10% 10%,90% 0%,40% 90%;
        filter:hue-rotate(15deg);
      }
      100%{
        background-position:20% 0%,80% 10%,60% 100%;
        filter:hue-rotate(30deg);
      }
    }

    .app{
      width:100%;
      max-width:900px;
      border-radius:26px;
      background:rgba(255,255,255,0.78);
      box-shadow:0 26px 70px rgba(15,23,42,0.25);
      backdrop-filter:blur(16px) saturate(160%);
      -webkit-backdrop-filter:blur(16px) saturate(160%);
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.8);
    }

    .app-inner{
      padding:18px 18px 16px;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .top-row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    .logo-circle{
      width:52px;height:52px;
      border-radius:999px;
      background:conic-gradient(from 200deg,#38bdf8,#a855f7,#22c55e,#f97316,#38bdf8);
      display:flex;align-items:center;justify-content:center;
      font-weight:800;font-size:1.3rem;
      color:#0f172a;
      box-shadow:0 0 18px rgba(129,140,248,0.65);
      flex-shrink:0;
    }
    .title-block{
      flex:1;
      text-align:right;
    }
    .title-block h1{
      font-size:1.35rem;
      letter-spacing:0.16em;
      text-transform:uppercase;
      color:#0f172a;
    }
    .title-block span{
      font-size:0.8rem;
      color:#6b7280;
    }

    .progress-wrapper{
      margin-top:4px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .progress-top{
      display:flex;
      justify-content:space-between;
      font-size:0.8rem;
      color:#6b7280;
    }
    .progress-bar{
      height:22px;
      border-radius:999px;
      border:1px solid rgba(209,213,219,0.9);
      background:rgba(255,255,255,0.7);
      overflow:hidden;
      position:relative;
    }
    .progress-fill{
      position:absolute;
      inset:2px;
      width:0%;
      border-radius:999px;
      background:linear-gradient(90deg,#f97316,#fb7185,#22c55e);
      box-shadow:0 0 18px rgba(249,115,22,0.6);
      transition:width 0.6s ease;
    }
    .score-main{
      font-size:0.95rem;
      text-align:right;
      color:#111827;
    }

    .question-side{
      margin-top:10px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .glass-box{
      border-radius:18px;
      border:1px solid rgba(255,255,255,0.9);
      background:rgba(255,255,255,0.85);
      box-shadow:0 16px 40px rgba(148,163,184,0.35);
      backdrop-filter:blur(12px) saturate(160%);
      -webkit-backdrop-filter:blur(12px) saturate(160%);
    }
    .question-box{
      padding:14px 14px 16px;
    }
    .question-tag{
      font-size:0.78rem;
      text-transform:uppercase;
      letter-spacing:0.12em;
      color:#9ca3af;
      margin-bottom:6px;
    }
    .question-text{
      font-size:1.25rem;
      font-weight:600;
      line-height:1.45;
      color:#111827;
    }

    .answers{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:10px;
    }
    .answer-btn{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(229,231,235,0.9);
      background:rgba(255,255,255,0.9);
      color:#111827;
      cursor:pointer;
      font-size:0.95rem;
      display:flex;
      align-items:center;
      gap:10px;
      transition:border-color 0.18s,background 0.18s,transform 0.08s,box-shadow 0.18s;
      box-shadow:0 10px 26px rgba(148,163,184,0.35);
    }
    .answer-letter{
      width:28px;height:28px;
      border-radius:999px;
      border:1px solid rgba(209,213,219,0.9);
      display:flex;align-items:center;justify-content:center;
      font-weight:600;font-size:0.88rem;
      color:#6b7280;
      background:rgba(255,255,255,0.95);
      flex-shrink:0;
    }
    .answer-btn:hover{
      border-color:#a855f7;
      background:linear-gradient(135deg,#fdfbff,#e5ecff);
      transform:translateY(-1px);
      box-shadow:0 14px 32px rgba(129,140,248,0.4);
    }
    .answer-btn.correct{
      border-color:#22c55e;
      background:linear-gradient(135deg,#dcfce7,#e0f2fe);
      box-shadow:0 14px 32px rgba(34,197,94,0.45);
    }
    .answer-btn.wrong{
      border-color:#fb7185;
      background:linear-gradient(135deg,#fee2e2,#fef9c3);
      box-shadow:0 14px 32px rgba(248,113,113,0.45);
    }
    .answer-btn.disabled{pointer-events:none;opacity:0.95;}

    .bottom-row{
      margin-top:12px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:0.85rem;
      color:#6b7280;
    }
    .next-btn{
      padding:9px 22px;
      border-radius:999px;
      border:1px solid rgba(209,213,219,0.9);
      background:rgba(255,255,255,0.9);
      color:#111827;
      font-weight:600;
      cursor:pointer;
      font-size:0.95rem;
      box-shadow:0 14px 32px rgba(148,163,184,0.45);
      transition:transform 0.08s,box-shadow 0.18s,border-color 0.18s,background 0.18s;
    }
    .next-btn:hover{
      transform:translateY(-1px);
      box-shadow:0 18px 40px rgba(129,140,248,0.5);
      border-color:#a855f7;
      background:linear-gradient(135deg,#fdfbff,#e0f2fe);
    }

    .motivation{
      margin-top:8px;
      font-size:0.9rem;
      color:#6b7280;
      min-height:1.2em;
    }
    .motivation span{
      display:inline-block;
      opacity:0;
      transform:translateY(6px);
      transition:opacity 0.35s ease,transform 0.35s ease;
    }
    .motivation span.show{
      opacity:1;
      transform:translateY(0);
    }

    .overlay{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,0.3);
      backdrop-filter:blur(18px);
      -webkit-backdrop-filter:blur(18px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:10;
    }
    .overlay.active{display:flex;}
    .overlay-card{
      width:min(420px,92vw);
      border-radius:24px;
      border:1px solid rgba(255,255,255,0.9);
      background:rgba(255,255,255,0.9);
      box-shadow:0 26px 70px rgba(148,163,184,0.6);
      padding:24px 20px 20px;
      text-align:center;
      color:#111827;
    }
    .overlay-card h2{
      font-size:1.4rem;
      letter-spacing:0.12em;
      text-transform:uppercase;
      margin-bottom:6px;
    }
    .overlay-card p{
      font-size:0.9rem;
      color:#6b7280;
      margin-bottom:18px;
    }
    .overlay-btn{
      margin-top:16px;
      width:100%;
      padding:10px 0;
      border-radius:999px;
      border:1px solid rgba(209,213,219,0.9);
      background:linear-gradient(135deg,#a855f7,#22c55e);
      color:white;
      font-weight:600;
      cursor:pointer;
      font-size:0.98rem;
      box-shadow:0 18px 40px rgba(129,140,248,0.7);
    }

    .final-bar{
      height:26px;
      border-radius:999px;
      border:1px solid rgba(209,213,219,0.95);
      background:rgba(255,255,255,0.9);
      overflow:hidden;
      position:relative;
    }
    .final-fill{
      position:absolute;
      inset:2px;
      width:0%;
      border-radius:999px;
      background:linear-gradient(90deg,#fb7185,#f97316,#facc15,#22c55e);
      box-shadow:0 0 26px rgba(248,113,113,0.7);
      transition:width 1s ease;
    }
    .final-score{
      margin-top:16px;
      font-size:2.3rem;
      font-weight:800;
      letter-spacing:0.18em;
      text-transform:uppercase;
      background:linear-gradient(90deg,#a855f7,#ec4899,#f97316,#22c55e);
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
      opacity:0;
      transform:translateY(10px) scale(0.9);
      transition:opacity 0.5s ease 0.9s,transform 0.5s ease 0.9s;
    }
    .final-score.show{
      opacity:1;
      transform:translateY(0) scale(1);
    }
    .final-comment{
      margin-top:6px;
      font-size:0.9rem;
      color:#6b7280;
    }

    .gallery-title{
      margin-top:18px;
      font-size:0.9rem;
      font-weight:600;
      color:#4b5563;
    }
    .gallery{
      margin-top:8px;
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(90px,1fr));
      gap:10px;
    }
    .thumb{
      width:100%;
      border-radius:12px;
      cursor:pointer;
      object-fit:cover;
      aspect-ratio:4/3;
      box-shadow:0 10px 26px rgba(148,163,184,0.6);
      transition:transform 0.18s ease,box-shadow 0.18s ease;
    }
    .thumb:hover{
      transform:translateY(-2px);
      box-shadow:0 16px 40px rgba(129,140,248,0.55);
    }

    .lightbox{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,0.75);
      backdrop-filter:blur(14px);
      -webkit-backdrop-filter:blur(14px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:30;
    }
    .lightbox.show{display:flex;}
    .lightbox img{
      max-width:92vw;
      max-height:92vh;
      border-radius:18px;
      box-shadow:0 26px 70px rgba(0,0,0,0.85);
      transform:scale(0.85);
      opacity:0;
      animation:zoomIn 0.25s ease forwards;
    }
    @keyframes zoomIn{
      to{transform:scale(1);opacity:1;}
    }

    @media(max-width:720px){
      .app-inner{padding:14px 12px 12px;}
      .title-block{text-align:left;}
      .top-row{align-items:flex-start;}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="app-inner">
<div class="glass-box" style="padding:0;overflow:hidden;margin-bottom:10px;">
  <video src="img/banner.mp4"
         autoplay
         muted
         loop
         playsinline
         style="width:100%;height:auto;display:block;">
  </video>
</div>

      <div class="progress-wrapper">
        <div class="progress-top">
          <span>Прогресс: <span id="progNum">0</span>/<span id="progTotal">20</span></span>
          <span id="scoreMini">Счёт: 0</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="scoreBar"></div>
        </div>
        <div class="score-main" id="scoreText">0/20</div>
      </div>

      <div class="question-side">
        <div class="glass-box question-box">
          <div class="question-tag" id="qTag">Вопрос</div>
          <div class="question-text" id="questionText">
            Нажмите «Пуск», чтобы начать раунд.
          </div>
        </div>
        <div class="answers" id="answers"></div>
      </div>

      <div class="bottom-row">
        <div>Вопросов в раунде: 20</div>
        <button class="next-btn" id="nextBtn">Пуск ➤</button>
      </div>
      <div class="motivation"><span id="motivationText">Готово к старту.</span></div>
    </div>
  </div>

  <div class="overlay active" id="startOverlay">
    <div class="overlay-card">
      <h2>Старт</h2>
      <p>Разогреем мозг 20 вопросами по 3D‑графике — от геометрии до света и игр.</p>
      <button class="overlay-btn" id="startBtn">Поехали ➤</button>
    </div>
  </div>

  <div class="overlay" id="endOverlay">
    <div class="overlay-card">
      <h2>Итог</h2>
      <p>Вот как заполнится твоя шкала в этот раз.</p>
      <div class="final-bar">
        <div class="final-fill" id="finalBar"></div>
      </div>
      <div class="final-score" id="finalScore">0 / 20</div>
      <div class="final-comment" id="finalComment"></div>

      <div class="gallery-title">Работы наших студентов</div>
      <div class="gallery">
        <img src="img/work1.jpg" alt="" class="thumb">
        <img src="img/work2.jpg" alt="" class="thumb">
        <img src="img/work3.jpg" alt="" class="thumb">
        <img src="img/work4.jpg" alt="" class="thumb">
        <img src="img/work5.jpg" alt="1" class="thumb">
        <img src="img/work6.jpg" alt="" class="thumb">
        <img src="img/work7.jpg" alt="" class="thumb">
        <img src="img/work8.jpg" alt="" class="thumb">
        <img src="img/work9.jpg" alt="" class="thumb">
      </div>

      <button class="overlay-btn" id="restartBtn">Ещё раунд ⟳</button>
    </div>
  </div>

  <div class="lightbox" id="lightbox">
    <img id="lightboxImg" src="" alt="Просмотр работы">
  </div>

  <script>
    const QUESTIONS_PER_RUN = 20;

    const praiseMessages = [
      "Отлично, чувствуется 3D‑мышление.",
      "Красиво попал, так держать.",
      "Вот это ответ, приятно смотреть.",
      "Очень уверенно, прям рабочий уровень.",
      "Чётко, видно, что ты в теме."
    ];
    const failMessages = [
      "Чуть мимо, но мозг уже прогревается.",
      "Не страшно, важнее, что ты идёшь дальше.",
      "Промах — тоже часть прокачки.",
      "В следующий раз именно этот вопрос зайдёт.",
      "Ошибки — топливo для роста."
    ];

    const allQuestions = [
      // 1–10 базовые полигоны/гео
      {
        text: "Что такое полигон в 3D‑модели?",
        options: [
          "Любая плоская картинка в сцене",
          "Минимальная плоская часть меша, ограниченная вершинами и рёбрами",
          "Любой трёхмерный объект в сцене",
          "Специальный тип текстуры"
        ],
        correctIndex: 1
      },
      {
        text: "Из каких основных элементов состоит полигональная сетка (mesh)?",
        options: [
          "Пиксели, слои и фильтры",
          "Вершины, рёбра и грани",
          "Кадры, ключи и кривые",
          "Шрифты, параграфы и стили"
        ],
        correctIndex: 1
      },
      {
        text: "Что лучше всего описывает понятие «mesh»?",
        options: [
          "Один полигон без связей",
          "Коллекция связанных полигонов, образующих объект",
          "Только материалы без геометрии",
          "Только анимация персонажа"
        ],
        correctIndex: 1
      },
      {
        text: "Чем low poly‑модель отличается от high poly?",
        options: [
          "Low poly всегда реалистичнее",
          "Low poly содержит меньше полигонов при сохранении общей формы",
          "High poly нельзя использовать в рендере",
          "High poly не подходит для скульпта"
        ],
        correctIndex: 1
      },
      {
        text: "В каком случае чаще всего используют low poly‑модели?",
        options: [
          "Для real‑time игр и мобильных приложений",
          "Только для печати на бумаге",
          "Исключительно для 2D‑анимации",
          "Только для статичных постеров 8K"
        ],
        correctIndex: 0
      },
      {
        text: "Что показывает режим отображения wireframe?",
        options: [
          "Только материалы и освещение",
          "Скелет рига без геометрии",
          "Только UV‑развёртку",
          "Структуру рёбер и полигонов без заливки"
        ],
        correctIndex: 3
      },
      {
        text: "Что такое N‑gon в 3D‑моделировании?",
        options: [
          "Полигон строго из четырёх вершин",
          "Полигон с количеством вершин больше четырёх",
          "Всегда треугольник",
          "Специальный тип нормалей"
        ],
        correctIndex: 1
      },
      {
        text: "Почему N‑gons не рекомендуют оставлять в зонах деформации?",
        options: [
          "Они делают рендер невозможным",
          "Они часто ломаются при subdivision и анимации",
          "Они запрещены в игровых движках",
          "Они автоматически превращаются в текстуры"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое нормаль поверхности?",
        options: [
          "Направление камеры в сцене",
          "Вектор, перпендикулярный поверхности полигона",
          "Направление скелетной кости",
          "Тип карты текстур"
        ],
        correctIndex: 1
      },
      {
        text: "В чём разница между глобальными (world) и локальными (local) координатами объекта?",
        options: [
          "Глобальные всегда равны нулю",
          "Локальные считаются от собственного центра объекта, глобальные — от начала сцены",
          "Глобальные есть только в играх",
          "Локальные используются только для камер"
        ],
        correctIndex: 1
      },

      // 11–20 моделирование
      {
        text: "Чем полигональное моделирование отличается от NURBS‑моделирования?",
        options: [
          "Полигональное основано на сетке, NURBS — на кривых",
          "NURBS всегда даёт меньше деталей",
          "Полигональное нельзя анимировать",
          "NURBS используют только в играх"
        ],
        correctIndex: 0
      },
      {
        text: "Что такое box‑моделинг?",
        options: [
          "Моделирование только примитивом сфера",
          "Пошаговое усложнение формы, начиная с простого куба/бокса",
          "Только скульпт без сетки",
          "Автоматическая генерация персонажа"
        ],
        correctIndex: 1
      },
      {
        text: "Для чего применяют subdivision (сабдив) к модели?",
        options: [
          "Чтобы уменьшить количество полигонов",
          "Чтобы сделать модель более гладкой и детализированной",
          "Чтобы удалить все вершины",
          "Чтобы обнулить трансформации"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем при моделировании персонажа используют модификатор Mirror?",
        options: [
          "Чтобы добавить отражения в материале",
          "Чтобы дублировать половину модели и сохранить симметрию",
          "Чтобы ускорить рендер",
          "Чтобы скрыть часть модели"
        ],
        correctIndex: 1
      },
      {
        text: "Какую задачу решает bevel на рёбрах?",
        options: [
          "Удаляет лишние полигоны",
          "Смягчает переходы и создаёт фаски на краях",
          "Меняет масштаб сцены",
          "Делает модель прозрачной"
        ],
        correctIndex: 1
      },
      {
        text: "В каких случаях удобнее начинать с high‑poly скульпта, а не с low‑poly сетки?",
        options: [
          "Когда нужна органика и сложные, плавные формы",
          "Когда модель — обычный куб",
          "Когда нет текстур",
          "Когда модель не будет анимироваться"
        ],
        correctIndex: 0
      },
      {
        text: "Для чего используют Boolean‑операции (union, difference, intersect)?",
        options: [
          "Для настройки освещения",
          "Для слияния и вырезания форм на уровне геометрии",
          "Только для анимации камеры",
          "Для изменения цвета текстур"
        ],
        correctIndex: 1
      },
      {
        text: "Что обычно называют блокингом (blockout) модели?",
        options: [
          "Финальный high‑poly скульпт",
          "Черновую форму из простых примитивов с правильными пропорциями",
          "Чистовую UV‑развёртку",
          "Только настройку материалов"
        ],
        correctIndex: 1
      },
      {
        text: "Почему при моделировании персонажа уделяют внимание сетке вокруг суставов?",
        options: [
          "Чтобы там было меньше вершин",
          "Эти зоны не анимируются",
          "Сетка должна хорошо деформироваться при сгибах",
          "Чтобы туда проще было назначать материалы"
        ],
        correctIndex: 2
      },
      {
        text: "Чем hard‑surface моделирование отличается от органического?",
        options: [
          "Hard‑surface — жёсткие техно‑формы, органика — живые плавные формы",
          "Hard‑surface нельзя анимировать",
          "Органика не бывает high‑poly",
          "Hard‑surface всегда low poly"
        ],
        correctIndex: 0
      },

      // 21–30 топология
      {
        text: "Что такое edge loop?",
        options: [
          "Последовательность рёбер, образующая логичный контур по поверхности",
          "Отдельное ребро без вершин",
          "Специальная текстура",
          "Скелетный сустав"
        ],
        correctIndex: 0
      },
      {
        text: "Почему плохая топология может вызвать артефакты при анимации?",
        options: [
          "Материалы перестают работать",
          "Свет не рендерится",
          "Сетка деформируется неравномерно и ломается в зонах сгиба",
          "Модель становится невидимой"
        ],
        correctIndex: 2
      },
      {
        text: "Что такое «полюс» (pole) в сетке?",
        options: [
          "Вершина, в которой сходится много рёбер",
          "Точка для крепления камеры",
          "Центр мировой координат",
          "Особый вид текстуры"
        ],
        correctIndex: 0
      },
      {
        text: "Почему треугольники и N‑gons стараются уводить из зон активной деформации?",
        options: [
          "Они всегда делают модель прозрачной",
          "Они не рендерятся в играх",
          "Они непредсказуемо subdiv‑ятся и ломают деформацию",
          "Так быстрее экспортируется FBX"
        ],
        correctIndex: 2
      },
      {
        text: "Для чего добавляют supporting edges на жёстких краях?",
        options: [
          "Чтобы уменьшить количество текстур",
          "Чтобы сохранить чёткий силуэт после subdivision",
          "Чтобы удалить нормали",
          "Чтобы изменить UV‑развёртку"
        ],
        correctIndex: 1
      },
      {
        text: "Что обычно подразумевают под «чистой топологией» лица?",
        options: [
          "Минимальное количество вершин",
          "Случайное расположение полигонов",
          "Логичные петли вокруг глаз, рта и носа для мимики",
          "Отсутствие UV‑развёртки"
        ],
        correctIndex: 2
      },
      {
        text: "Почему важно избегать слишком вытянутых узких полигонов?",
        options: [
          "Они не поддерживаются видеокартами",
          "Они плохо ведут себя при деформации и освещении",
          "Они автоматически превращаются в N‑gons",
          "Их нельзя текстурировать"
        ],
        correctIndex: 1
      },
      {
        text: "Как по сетке понять, что модель делали под subdivision, а не под game‑lowpoly?",
        options: [
          "Очень редкая сетка без контуров",
          "Равномерные квады и поддерживающие рёбра вдоль краёв",
          "Только треугольники",
          "Только N‑gons"
        ],
        correctIndex: 1
      },
      {
        text: "Почему треугольники допустимы на статичных частях модели?",
        options: [
          "Они автоматически анимируются",
          "Они не влияют на деформацию, если зона не сгибается",
          "Они ускоряют свет",
          "Они заменяют текстуры"
        ],
        correctIndex: 1
      },
      {
        text: "Что говорит о том, что сетка персонажа оптимизирована под мобильную игру?",
        options: [
          "Много мелких деталей и очень плотная сетка",
          "Минимум полигонов, акцент на силуэт и нормали",
          "Только N‑gons",
          "Отсутствие UV"
        ],
        correctIndex: 1
      },

      // 31–40 текстуры / PBR
      {
        text: "Что такое текстура в 3D‑графике?",
        options: [
          "Всегда только цвет объекта",
          "2D‑изображение, проецируемое на поверхность модели",
          "Тип источника света",
          "Скелет для анимации"
        ],
        correctIndex: 1
      },
      {
        text: "Чем диффузная (albedo) карта отличается от normal map?",
        options: [
          "Albedo задаёт цвет, normal — микрорельеф для освещения",
          "Normal отвечает за прозрачность",
          "Albedo управляет металличностью",
          "Они взаимозаменяемы"
        ],
        correctIndex: 0
      },
      {
        text: "Какую роль играет roughness‑карта в PBR‑материале?",
        options: [
          "Управляет высотой геометрии",
          "Определяет шероховатость поверхности и размытие бликов",
          "Отвечает за цвет тени",
          "Контролирует скорость анимации"
        ],
        correctIndex: 1
      },
      {
        text: "Чем bump map отличается от normal map?",
        options: [
          "Bump хранит высоту в одном канале, normal — направление нормали в трёх",
          "Normal используется только в 2D",
          "Bump не влияет на освещение",
          "Разницы нет"
        ],
        correctIndex: 0
      },
      {
        text: "Что кодирует metallic‑карта в PBR?",
        options: [
          "Температуру света",
          "Области поверхности, которые ведут себя как металл",
          "Прозрачные участки",
          "Размер модели"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем используют ambient occlusion‑карту?",
        options: [
          "Для управления движением камеры",
          "Для добавления мягких теней в углублениях формы",
          "Для настройки DOF",
          "Для сжатия текстур"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое procedural‑текстуры?",
        options: [
          "Всегда рисованные вручную",
          "Генерируемые алгоритмами, а не хранящиеся как обычные изображения",
          "Только HDR",
          "Текстуры, которые нельзя редактировать"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое seamless‑текстура?",
        options: [
          "Текстура с прозрачным фоном",
          "Текстура, которая повторяется без видимых швов",
          "Всегда чёрно‑белая карта",
          "Текстура только для персонажей"
        ],
        correctIndex: 1
      },
      {
        text: "Почему важно соблюдать единый стиль текстур в одной сцене?",
        options: [
          "Иначе рендер не запустится",
          "Чтобы сцена не выглядела собранной из чужих ассетов",
          "Чтобы уменьшить размер файла",
          "Чтобы ускорить импорт"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое tiling текстур?",
        options: [
          "Случайное вращение текстур",
          "Повторение одной и той же текстуры по поверхности",
          "Удаление текстур",
          "Сжатие текстур"
        ],
        correctIndex: 1
      },

      // 41–50 UV
      {
        text: "Что такое UV‑развёртка?",
        options: [
          "Анимация камеры",
          "Схема соответствия точек модели координатам 2D‑текстуры",
          "Настройка рендера",
          "Набор ключевых кадров"
        ],
        correctIndex: 1
      },
      {
        text: "Почему без корректной UV‑развёртки сложно нанести детализированную текстуру?",
        options: [
          "Модель не рендерится",
          "Текстура будет растягиваться и смещаться случайно",
          "Текстуры нельзя импортировать",
          "Нормали перестают работать"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое UV‑seam?",
        options: [
          "Ребро, по которому разорван UV‑остров",
          "Тип источника света",
          "Центр мира",
          "Особый режим рендера"
        ],
        correctIndex: 0
      },
      {
        text: "Зачем для проверки UV используют checker‑текстуру (клетку)?",
        options: [
          "Чтобы усилить блики",
          "Чтобы увидеть растяжения и неправильный масштаб",
          "Чтобы ускорить рендер",
          "Чтобы добавить бамп"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое оверлап (overlapping UVs)?",
        options: [
          "Всегда фатальная ошибка",
          "Наложение нескольких UV‑островов друг на друга",
          "Смещение источников света",
          "Особый тип нормалей"
        ],
        correctIndex: 1
      },
      {
        text: "Когда допустимо использовать overlapping UVs?",
        options: [
          "Никогда",
          "Когда можно зеркалить детали и экономить текстурное место",
          "Только в оффлайн‑рендере",
          "Только для камер"
        ],
        correctIndex: 1
      },
      {
        text: "Почему при запекании нормалей важно избегать случайного UV‑оверлапа?",
        options: [
          "Иначе модель станет прозрачной",
          "Информация с разных участков high‑poly смешается и даст артефакты",
          "Нормали выключатся",
          "Размер текстуры уменьшится"
        ],
        correctIndex: 1
      },
      {
        text: "Что показывает равномерный размер клеток checker‑текстуры на модели?",
        options: [
          "Что модель слишком low poly",
          "Что масштаб UV примерно одинаков и без сильных растяжений",
          "Что текстур нет",
          "Что освещение некорректно"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем иногда разделяют UV‑острова по швам модели?",
        options: [
          "Чтобы усложнить жизнь текстурщику",
          "Чтобы уменьшить растяжения и увести швы в менее заметные места",
          "Чтобы отключить тени",
          "Чтобы удалить нормали"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое UDIM‑подход?",
        options: [
          "Использование только одной текстуры 1×1",
          "Разбиение модели на несколько тайлов UV‑пространства для высоких разрешений",
          "Отказ от UV‑развёртки",
          "Только процедурные материалы"
        ],
        correctIndex: 1
      },

      // 51–60 свет / рендер
      {
        text: "Чем point light отличается от directional light?",
        options: [
          "Point светит из точки во все стороны, directional — как параллельный поток из бесконечности",
          "Directional нельзя использовать в играх",
          "Point не даёт теней",
          "Разницы нет"
        ],
        correctIndex: 0
      },
      {
        text: "Что такое HDRI‑карта в освещении?",
        options: [
          "Чёрно‑белая маска",
          "Панорамное изображение с расширенным диапазоном яркости, используемое как источник света и окружение",
          "Низкокачественная текстура",
          "Тип геометрии"
        ],
        correctIndex: 1
      },
      {
        text: "Что даёт глобальное освещение (Global Illumination) сцене?",
        options: [
          "Только ускорение рендера",
          "Учёт переотражений света от поверхностей для реалистичных теней и цвета",
          "Отсутствие теней",
          "Отключение всех источников света"
        ],
        correctIndex: 1
      },
      {
        text: "Почему слишком много ярких источников света может сделать сцену «плоской»?",
        options: [
          "Рендер становится чёрно‑белым",
          "Тени пропадают и теряется контраст объёмов",
          "Материалы исчезают",
          "Камера не работает"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое soft shadow?",
        options: [
          "Тень без света",
          "Жёсткая чёрная тень",
          "Мягкая тень с размытым краем от большого/дальнего источника",
          "Отсутствие тени"
        ],
        correctIndex: 2
      },
      {
        text: "Что такое depth of field (глубина резкости) в рендере?",
        options: [
          "Измерение глубины модели",
          "Эффект резкости в одной зоне и размытия переднего/заднего плана",
          "Тип рендера без света",
          "Только эффект в видеоредакторе"
        ],
        correctIndex: 1
      },
      {
        text: "Чем real‑time рендер в игровом движке обычно отличается от offline‑рендера?",
        options: [
          "Он всегда точнее по физике",
          "Он быстрее, но ограничен по сложности света и материалов",
          "Он не использует текстуры",
          "Он не подходит для игр"
        ],
        correctIndex: 1
      },
      {
        text: "Почему на path‑tracing рендерах появляется шум (noise)?",
        options: [
          "Неверный формат текстуры",
          "Недостаточно сэмплов для оценки света и переотражений",
          "Слишком много полигонов",
          "Слишком длинное имя файла"
        ],
        correctIndex: 1
      },
      {
        text: "Что делает эффект motion blur в анимации?",
        options: [
          "Удаляет все ключи",
          "Имитация смаза движения при перемещении объектов или камеры",
          "Меняет цвет материалов",
          "Выключает освещение"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое ambient light в сцене?",
        options: [
          "Направленный жёсткий источник",
          "Фоновый рассеянный свет, заполняющий тени",
          "Всегда красный свет",
          "Только для мобильных игр"
        ],
        correctIndex: 1
      },

      // 61–70 игры / realtime
      {
        text: "Почему для игровых моделей важно ограничивать количество полигонов?",
        options: [
          "Чтобы файл открывался только в одной программе",
          "Чтобы укладываться в бюджет по производительности и памяти",
          "Чтобы модель нельзя было анимировать",
          "Чтобы отключить текстуры"
        ],
        correctIndex: 1
      },
      {
        text: "Чем модель для in‑game отличается от модели для кат‑сцены/прома?",
        options: [
          "In‑game обычно более оптимизирована по полигонам и текстурам",
          "Кат‑сцену нельзя анимировать",
          "Промо‑модель всегда без текстур",
          "Разницы нет"
        ],
        correctIndex: 0
      },
      {
        text: "Что такое LOD‑модели?",
        options: [
          "Только модели для VR",
          "Несколько уровней детализации одного объекта для разных дистанций",
          "Модели без текстур",
          "Модели только для рендера"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое atlas‑текстура?",
        options: [
          "Текстура только для карт",
          "Одна текстура, на которой размещено несколько объектов/деталей",
          "Текстура с картой нормалей и высот",
          "Всегда 8К текстура"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем создают отдельную collision‑модель?",
        options: [
          "Чтобы улучшить цвет объекта",
          "Чтобы упростить просчёт столкновений и физики",
          "Чтобы сделать UV‑развёртку",
          "Чтобы ускорить рендер оффлайн"
        ],
        correctIndex: 1
      },
      {
        text: "Чем baked lighting отличается от динамического освещения?",
        options: [
          "Baked нельзя сохранять",
          "Baked заранее запекается в текстуры/карты, динамическое считается в реальном времени",
          "Динамическое всегда чёрно‑белое",
          "Разницы нет"
        ],
        correctIndex: 1
      },
      {
        text: "Почему важно следить за направлением нормалей на игровых моделях?",
        options: [
          "Иначе UV не создаются",
          "Неправильные нормали могут вызывать чёрные дырки и странные тени",
          "Текстуры не импортируются",
          "Камера не двигается"
        ],
        correctIndex: 1
      },
      {
        text: "Что такое skeletal animation?",
        options: [
          "Анимация только камер",
          "Анимация на основе скелета с костями и скинингом меша",
          "Анимация текстур",
          "Только 2D‑анимация"
        ],
        correctIndex: 1
      },
      {
        text: "Почему в real‑time сценах часто используют low poly + нормали вместо чистого high poly?",
        options: [
          "High poly нельзя экспортировать",
          "Low poly с нормалями даёт похожий визуал при меньшей нагрузке",
          "Low poly лучше для оффлайн‑рендера",
          "High poly не поддерживают видеокарты"
        ],
        correctIndex: 1
      },
      {
        text: "По какому признаку можно заметить, что модели в игре не используют normal map?",
        options: [
          "Сцена чёрно‑белая",
          "Поверхности выглядят слишком плоско, без микрорельефа и градаций света",
          "Все материалы прозрачные",
          "UV‑развёртки отсутствуют"
        ],
        correctIndex: 1
      },

      // 71–80 high poly / bake
      {
        text: "Зачем делают high‑poly скульпт, если в игре всё равно low‑poly?",
        options: [
          "Чтобы увеличить вес файла",
          "Чтобы запечь на low‑poly карты с деталями (normal, AO и т.п.)",
          "Чтобы модель нельзя было экспортировать",
          "Чтобы не делать UV"
        ],
        correctIndex: 1
      },
      {
        text: "Что обычно запекают с high‑poly на low‑poly?",
        options: [
          "Только анимацию",
          "Информацию о деталях поверхности: нормали, AO, иногда высоту",
          "Камеры и свет",
          "Размер сцены"
        ],
        correctIndex: 1
      },
      {
        text: "Почему плохая топология на high‑poly усложняет ретопологию?",
        options: [
          "Ретопология становится невозможной технически",
          "Сложнее понять логику форм и проложить чистые лупы",
          "UV нельзя сделать",
          "Текстуры не работают"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем добавляют вторичные и третичные детали (поры, мелкие царапины) на high‑poly?",
        options: [
          "Чтобы увеличить количество полигонов ради спорта",
          "Чтобы при запекании получить реалистичный микрорельеф",
          "Чтобы облегчить модель",
          "Чтобы убрать нормали"
        ],
        correctIndex: 1
      },
      {
        text: "Почему чрезмерный шум деталей на high‑poly плохо переносится в низком разрешении текстур?",
        options: [
          "Он делает UV невозможной",
          "Детали превращаются в кашу и выглядят грязно",
          "Тени пропадают",
          "Свет не рассчитывается"
        ],
        correctIndex: 1
      },
      {
        text: "Чем отличается high‑poly персонаж для статичного рендера от игрового варианта?",
        options: [
          "Игровой обычно сильно оптимизирован по полигонам и текстурам",
          "Игровой всегда без текстур",
          "Статичный нельзя рендерить",
          "Разницы нет"
        ],
        correctIndex: 0
      },
      {
        text: "Как по нормал‑карте можно заметить артефакты запекания?",
        options: [
          "Если она чёрно‑белая",
          "Рваные швы, резкие полосы и ломанные переходы",
          "Если она слишком цветная",
          "Если она больше 1К"
        ],
        correctIndex: 1
      },
      {
        text: "Когда displacement‑карта оправдана даже в real‑time?",
        options: [
          "Никогда",
          "В близких кинематографичных кадрах, где нужна геометрическая детализация",
          "Только для UI",
          "Только для скелета"
        ],
        correctIndex: 1
      },
      {
        text: "Почему для bake важно совпадение позиций и масштаба high‑poly и low‑poly?",
        options: [
          "Чтобы рендер был цветным",
          "Чтобы лучи запекания правильно попадали с high на low",
          "Чтобы UV не исчезла",
          "Чтобы уменьшить размер файла"
        ],
        correctIndex: 1
      },
      {
        text: "Какой плюс даёт использование cage‑меша при запекании?",
        options: [
          "Ускоряет анимацию",
          "Позволяет контролировать направление лучей и уменьшить артефакты",
          "Удаляет UV",
          "Меняет цвет нормалей"
        ],
        correctIndex: 1
      },

      // 81–90 пайплайн / профессии
      {
        text: "Какой порядок этапов ближе к реальному пайплайну персонажа для игры?",
        options: [
          "Текстуры → концепт → риг",
          "Концепт → моделинг → текстуринг → риг → анимация → интеграция",
          "Риг → анимация → концепт → моделинг",
          "Интеграция → моделинг → концепт"
        ],
        correctIndex: 1
      },
      {
        text: "Кто такой 3D generalist?",
        options: [
          "Художник только по текстурам",
          "Специалист, который закрывает несколько этапов пайплайна",
          "Только риггер",
          "Только композитор"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем нужен turnaround‑референс персонажа?",
        options: [
          "Чтобы проверить FPS",
          "Чтобы моделлер видел персонажа спереди, сзади и сбоку с согласованными пропорциями",
          "Чтобы настроить свет",
          "Чтобы сделать UV"
        ],
        correctIndex: 1
      },
      {
        text: "Почему важно заранее договориться о стилистике (realistic / stylized)?",
        options: [
          "Иначе нельзя экспортировать модель",
          "Чтобы моделинг, текстуры и свет не конфликтовали по визуалу",
          "Чтобы выбрать размер текстур",
          "Чтобы задать количество костей"
        ],
        correctIndex: 1
      },
      {
        text: "Что подразумевают под non‑destructive workflow в моделинге?",
        options: [
          "Удаление истории действий",
          "Использование модификаторов и процедурных шагов, которые можно править позже",
          "Работу без сохранений",
          "Отказ от UV"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем в продакшене нужна аккуратная система имён файлов, коллекций и материалов?",
        options: [
          "Чтобы увеличить вес проекта",
          "Чтобы команда быстро ориентировалась в сцене и избежала путаницы",
          "Чтобы рендер был быстрее",
          "Чтобы включить PBR"
        ],
        correctIndex: 1
      },
      {
        text: "Как 3D‑графика помогает в архитектурной визуализации?",
        options: [
          "Считает смету стройки",
          "Позволяет показать, как будет выглядеть пространство ещё до строительства",
          "Пишет юридические документы",
          "Меняет температуру в помещении"
        ],
        correctIndex: 1
      },
      {
        text: "Чем пайплайн персонажа для анимационного фильма отличается от игрового?",
        options: [
          "В фильме нет рига",
          "В кино можно позволить сложнее риг, больше полигонов и тяжёлые симуляции",
          "В играх не нужно текстурирование",
          "Разницы нет"
        ],
        correctIndex: 1
      },
      {
        text: "Кто в команде обычно отвечает за постановку света и финальный рендер?",
        options: [
          "Rigging artist",
          "Lighting / LookDev artist",
          "Concept artist",
          "UI designer"
        ],
        correctIndex: 1
      },
      {
        text: "Кто чаще всего подготавливает ассеты под оптимизацию для движка (LOD, коллизии, атласы)?",
        options: [
          "Sound designer",
          "Technical / game artist",
          "Storyboard artist",
          "Motion designer 2D"
        ],
        correctIndex: 1
      },

      // 91–100 общие / микс
      {
        text: "Что даёт хорошая силуетная читаемость модели персонажа?",
        options: [
          "Быстрый рендер",
          "Персонажа легко узнают даже без деталей и текстур",
          "Меньше полигонов",
          "Проще UV"
        ],
        correctIndex: 1
      },
      {
        text: "Почему важно регулярно проверять модель в разных ракурсах и фокусных расстояниях камеры?",
        options: [
          "Чтобы менять цвет",
          "Чтобы избежать странных пропорций и искажений в финальных планах",
          "Чтобы уменьшить размер файла",
          "Чтобы отключить тени"
        ],
        correctIndex: 1
      },
      {
        text: "Чем 3D‑анимация отличается от простой покадровой смены статичных рендеров?",
        options: [
          "Наличием рига и интерполяции между позами во времени",
          "Только размером файла",
          "Использованием 2D‑спрайтов",
          "Отказом от камер"
        ],
        correctIndex: 0
      },
      {
        text: "Почему сцена с идеальными зеркальными материалами может выглядеть «ненастояще»?",
        options: [
          "Так не бывает в реальности, почти все поверхности имеют roughness",
          "Рендер не поддерживает зеркала",
          "Нельзя добавить свет",
          "Слишком мало полигонов"
        ],
        correctIndex: 0
      },
      {
        text: "Какую ключевую роль играет reference при работе 3D‑художника?",
        options: [
          "Увеличивает время работы",
          "Помогает принимать осознанные решения по форме, материалам и свету",
          "Запрещает фантазию",
          "Нужен только новичкам"
        ],
        correctIndex: 1
      },
      {
        text: "Почему важно следить за реальным масштабом объектов в сцене (метры, сантиметры)?",
        options: [
          "Иначе файл не откроется",
          "От масштаба зависят свет, физика, симуляции и удобство работы",
          "Только чтобы выбрать размер текстуры",
          "В масштабе нет смысла"
        ],
        correctIndex: 1
      },
      {
        text: "Какая главная цель ретопологии high‑poly модели?",
        options: [
          "Сделать модель тяжелее",
          "Создать чистую, оптимизированную сетку для анимации и игр",
          "Удалить детали",
          "Изменить цвет материалов"
        ],
        correctIndex: 1
      },
      {
        text: "Что даёт использование reference‑кадров из фильмов и игр при изучении света и композиции?",
        options: [
          "Только копирование стиля",
          "Понимание, как профи решают сцены по свету и цвету",
          "Увеличение шума на рендерах",
          "Снижение FPS"
        ],
        correctIndex: 1
      },
      {
        text: "Зачем 3D‑графику используют в кино, даже когда можно снять всё вживую?",
        options: [
          "Чтобы усложнить монтаж",
          "Чтобы создавать миры, объекты и эффекты, которые невозможно или слишком дорого снимать реально",
          "Только ради титров",
          "Чтобы уменьшить качество картинки"
        ],
        correctIndex: 1
      },
      {
        text: "Как 3D‑художнику помогает знание основ фотографии (композиция, свет, фокусное расстояние)?",
        options: [
          "Совсем не связано",
          "Прямо влияет на качество рендера и восприятие кадра",
          "Только мешает",
          "Нужно лишь для печати"
        ],
        correctIndex: 1
      }
    ];

    let selectedQuestions = [];
    let currentIndex = 0;
    let score = 0;
    let answered = false;
    let quizStarted = false;

    const els = {
      progNum: document.getElementById("progNum"),
      progTotal: document.getElementById("progTotal"),
      scoreMini: document.getElementById("scoreMini"),
      scoreBar: document.getElementById("scoreBar"),
      scoreText: document.getElementById("scoreText"),
      qTag: document.getElementById("qTag"),
      questionText: document.getElementById("questionText"),
      answers: document.getElementById("answers"),
      nextBtn: document.getElementById("nextBtn"),
      startOverlay: document.getElementById("startOverlay"),
      startBtn: document.getElementById("startBtn"),
      endOverlay: document.getElementById("endOverlay"),
      restartBtn: document.getElementById("restartBtn"),
      finalBar: document.getElementById("finalBar"),
      finalScore: document.getElementById("finalScore"),
      finalComment: document.getElementById("finalComment"),
      motivationText: document.getElementById("motivationText"),
      lightbox: document.getElementById("lightbox"),
      lightboxImg: document.getElementById("lightboxImg")
    };

    els.progTotal.textContent = QUESTIONS_PER_RUN;

    function randFrom(arr){return arr[Math.floor(Math.random()*arr.length)];}

    function setMotivation(text){
      els.motivationText.classList.remove("show");
      void els.motivationText.offsetWidth;
      els.motivationText.textContent = text;
      els.motivationText.classList.add("show");
    }

    function pickQuestions(){
      const idx = allQuestions.map((_,i)=>i);
      idx.sort(()=>Math.random()-0.5);
      const slice = idx.slice(0,QUESTIONS_PER_RUN);
      selectedQuestions = slice.map(i=>({...allQuestions[i]}));
    }

    function initGallery(){
      const thumbs = document.querySelectorAll(".thumb");
      thumbs.forEach(img=>{
        img.addEventListener("click",()=>{
          els.lightboxImg.src = img.src;
          els.lightbox.classList.add("show");
        });
      });
      els.lightbox.addEventListener("click",()=>{
        els.lightbox.classList.remove("show");
      });
    }
    initGallery();

    function startQuiz(){
      pickQuestions();
      currentIndex = 0;
      score = 0;
      quizStarted = true;
      els.startOverlay.classList.remove("active");
      els.endOverlay.classList.remove("active");
      els.finalBar.style.width = "0%";
      els.finalScore.classList.remove("show");
      setMotivation("Поехали, первый вопрос уже ждёт.");
      updateProgress();
      renderQuestion();
    }

    function updateProgress(){
      els.progNum.textContent = currentIndex;
      els.scoreMini.textContent = `Счёт: ${score}`;
      els.scoreText.textContent = `${score}/${QUESTIONS_PER_RUN}`;
      const progress = (currentIndex/QUESTIONS_PER_RUN)*100;
      els.scoreBar.style.width = progress + "%";
    }

    function maybeMotivationBetween(){
      if(Math.random() < 0.35){
        setMotivation(randFrom(praiseMessages));
      }else{
        setMotivation("Следующий вопрос — ещё один шаг к сильному результату.");
      }
    }

    function renderQuestion(){
      const q = selectedQuestions[currentIndex];
      answered = false;
      els.qTag.textContent = `Вопрос ${currentIndex+1}`;
      els.questionText.textContent = q.text;
      els.answers.innerHTML = "";
      setMotivation("Выбери вариант, опираясь на свой опыт и чувство логики.");

      const letters = "ABCDE".split("");
      q.options.forEach((opt,i)=>{
        const btn = document.createElement("button");
        btn.className = "answer-btn";
        btn.innerHTML = `
          <div class="answer-letter">${letters[i]||""}</div>
          <span>${opt}</span>
        `;
        btn.onclick = ()=>handleAnswer(i,btn);
        els.answers.appendChild(btn);
      });

      els.nextBtn.textContent = currentIndex===QUESTIONS_PER_RUN-1 ? "Результат" : "Далее ➤";
      updateProgress();
    }

    function handleAnswer(selectedIndex,btnEl){
      if(!quizStarted || answered) return;
      answered = true;
      const q = selectedQuestions[currentIndex];
      const buttons = els.answers.querySelectorAll(".answer-btn");

      buttons.forEach((b,i)=>{
        b.classList.add("disabled");
        if(i===q.correctIndex) b.classList.add("correct");
      });

      if(selectedIndex===q.correctIndex){
        score++;
        btnEl.classList.add("correct");
        setMotivation(randFrom(praiseMessages));
      }else{
        btnEl.classList.add("wrong");
        setMotivation(randFrom(failMessages));
      }

      els.scoreMini.textContent = `Счёт: ${score}`;
      els.scoreText.textContent = `${score}/${QUESTIONS_PER_RUN}`;
    }

    function showResults(){
      const percent = Math.round((score/QUESTIONS_PER_RUN)*100);
      els.finalScore.textContent = `${score} / ${QUESTIONS_PER_RUN}`;
      els.finalComment.textContent =
        percent>=85 ? "Очень мощно. Этот результат уже можно показывать клиентам и друзьям." :
        percent>=60 ? "Крепко. Ещё пару заходов — и шкала будет забита под завязку." :
        percent>=30 ? "Неплохо для разминки. С каждым кругом будет заметно лучше." :
                      "Старт есть. Если не бросать, через пару недель ты сам не узнаешь свой уровень.";

      els.endOverlay.classList.add("active");
      requestAnimationFrame(()=>{
        els.finalBar.style.width = percent + "%";
        els.finalScore.classList.add("show");
      });
    }

    els.nextBtn.onclick = ()=>{
      if(!quizStarted){
        startQuiz();
        return;
      }
      if(!answered) return;
      if(currentIndex<QUESTIONS_PER_RUN-1){
        currentIndex++;
        renderQuestion();
        maybeMotivationBetween();
      }else{
        showResults();
      }
    };

    els.startBtn.onclick = startQuiz;
    els.restartBtn.onclick = startQuiz;
  </script>
</body>
</html>
